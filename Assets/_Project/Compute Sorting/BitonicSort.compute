#pragma kernel BitonicSort
#pragma kernel ComputeDistances

#define THREAD_NUM 1024
#define SWAP(x, y) { PosDistData temp = x; x = y; y = temp; }

struct PosDistData
{
    float3 pos;
    float distance;
};

RWStructuredBuffer<PosDistData> posDistData;
float3 testPos;

uint Size;
uint Stride;



[numthreads(THREAD_NUM, 1, 1)]
void ComputeDistances(uint3 id : SV_DispatchThreadID)
{   
    uint idx = id.x;
    float3 diff = posDistData[idx].pos - testPos;
    posDistData[idx].distance = dot(diff, diff);    
}



[numthreads(THREAD_NUM, 1, 1)]
void BitonicSort(uint3 id : SV_DispatchThreadID)
{

    uint idx = id.x;

    uint dir = (idx & (Size << 1)) != 0;
    GroupMemoryBarrierWithGroupSync();
    uint swapIdx = idx ^ Stride;
    if (swapIdx > idx)
    {
        if ((idx & Size) == 0 ^ dir)
        {
            if (posDistData[idx].distance < posDistData[swapIdx].distance)
                SWAP(posDistData[idx], posDistData[swapIdx]);
        }
        else
        {
            if (posDistData[idx].distance > posDistData[swapIdx].distance)
                SWAP(posDistData[idx], posDistData[swapIdx]);
        }
    }  
}


// REFS
// GPT CHat: https://chat.openai.com/share/ec8dff5a-a179-4203-a473-a1789e3ae6d8
// Bitonic sort explanation https://www.geeksforgeeks.org/bitonic-sort/

// TODO
// Check to see how to work with buffers larger than the threadlimit of 1024

// LEARNINGS
// Profile dist vs sqr dist performance
// . seemed to get the same results,meaning the calls were likly the expensive part not the ops
// Square dist can be calculated by getting the dot product of a vector against itself dot(x,x) bc its just multiplying the vector byself giving the square
// Can use defines to make code more readable, i.e. using swap macro to shorthand the swapping and poss


// Explain the bitwise operators 
// - << shift bit one to the left effectively multiplying by 2
// - >> shifts bit one to the right effectively dividing by 2 (floor(x/2))
// x & y takes two bytes and compares bits, if each bit is 1 it sets the result bit to 1
// x ^ y takes two bytes and compares bits, if each bit is different it sets the result bit to 1





// NOTES
// Bitonic Sort is a classic parallel algorithm for sorting. 
//The number of comparisons done by Bitonic sort is more than popular sorting algorithms like Merge Sort
// does O(log N) comparisons, but Bitonic sort is better for parallel implementation because we always 
// compare elements in a predefined sequence and the sequence of comparison doesnt depend on data. 
// Therefore it is suitable for implementation in hardware and parallel processor array.
//
// Bitonic Sort can only be done if the number of elements to sort is power of 2. The procedure of bitonic sequence 
// fails if the number of elements is not in the aforementioned quantity precisely.