#pragma kernel WhiteNoise
#pragma kernel ValueNoise
#pragma kernel WorleyNoise

#include "HLSLExtension.hlsl"


//---- VARIABLES
//
RWTexture2D<float> OutputTex;

float freq = 4;
uint resolution = 512;

bool additionalLayer = false;
float valueScalar = 1;

float time;


//---- PRAGMAS
//
[numthreads(8,8,1)]
void WhiteNoise (uint3 id : SV_DispatchThreadID)
{
    OutputTex[id.xy] = noise2x1(id.xy);
}


[numthreads(8,8,1)]
void ValueNoise (uint3 id : SV_DispatchThreadID)
{
    float2 uv = float2((float)id.x/resolution,
                        (float)id.y/resolution);
    
    float2 scaledUv = uv * freq;
    float2 gridUV = float2(frac(scaledUv.x), frac(scaledUv.y));
    gridUV = smoothstep(0,1,gridUV);
    float2 gridID = floor(scaledUv);
    
    // Get noise values at grid corners
    float botLeft = noise2x1(gridID);
    float botRight = noise2x1(gridID+float2(1.0,0));
    float topLeft = noise2x1(gridID+float2(0.0,1.0));
    float topRight = noise2x1(gridID+float2(1.0,1.0));

    float botLerp = lerp(botLeft, botRight, gridUV.x);
    float topLerp = lerp(topLeft, topRight, gridUV.x);
    float topBotLerp = lerp(botLerp, topLerp, gridUV.y);

    // Noise values aren't the same at corner sample
    if(additionalLayer)
        OutputTex[id.xy] += topBotLerp * valueScalar;
    else
        OutputTex[id.xy] = topBotLerp;    
}

[numthreads(8,8,1)]
void WorleyNoise (uint3 id : SV_DispatchThreadID)
{
    float2 uv = float2((float)id.x/resolution,
                        (float)id.y/resolution);
       
    float2 scaledUv = uv * freq;
    float2 gridID = floor(scaledUv);
    float2 centeredGridUV = frac(scaledUv) - 0.5;

    float minDistFromPixel = 1000;
    
    for(int i = -1.0; i <= 1.0; i++)
    {
        for(int j = -1.0; j <= 1.0; j++)
        {
            // not sure why i have to scale by freq here
            float2 adjGridCoord = float2(i,j);            

            // Get noise sample in adjacent grid // DEBUG - Stable
            float2 noise = noise2x2(gridID + adjGridCoord + 1.23);

            // Add sin of noise ot both components (modulates X and Y kind of like the ABC logo)
            float2 pointOnAdjGrid = adjGridCoord + sin(time * noise) * .5;
            float3 point3D = float3(pointOnAdjGrid, sin(time * noise.x) * 1);
            float3 centeredGrid3D = float3(centeredGridUV, 0);

            // Get min dist to point
            //float dist = length(centeredGridUV - pointOnAdjGrid);
            float dist = length(point3D - centeredGrid3D);
            //float dist = ManhattanDistance(centeredGridUV, pointOnAdjGrid);
            //float dist = ChebyshevDistance(centeredGridUV, pointOnAdjGrid);
            //float dist = MinkowskiDistance(centeredGridUV, pointOnAdjGrid, .5f);
            //float dist = HammingDistance(centeredGridUV, pointOnAdjGrid);
            minDistFromPixel = min(dist, minDistFromPixel);
        }
    }


    // Noise values aren't the same at corner sample
    if(additionalLayer)
        OutputTex[id.xy] += minDistFromPixel;
    else
        OutputTex[id.xy] = 1-minDistFromPixel;   
}