#pragma kernel RunRaymarcher

// The number of steps to march
#define MAX_STEPS 100
// The threshold to consider a hit
#define HIT_THRESHOLD 0.01
// The maximum distance to march
#define MAX_DISTANCE 30.0
// Assume a maximum number of spheres
#define MAX_SPHERES 10

//----- SPHERES ----------------------------
//
// Define a struct to represent a sphere
struct Sphere
{
    float3 position;
    float radius;
};

StructuredBuffer<Sphere> spheres;
uint numSpheres;
//----------------------------

// The render target
RWTexture2D<float4> Result;

// The resolution of the target texture
float2 _Resolution;

// Camera parameters
float4x4 _CameraToWorld; // Transforms a point from camera space to world space
float4x4 _InverseProjection; // Transforms a point from projection space to camera space

// Sphere parameters
float3 _SpherePosition;
float _SphereRadius;

float _Smoothing;
float _SphereOffset; 





// Raymarch a sphere SDF
float SphereSDF(float3 p, Sphere sphere)
{
    return length(p - sphere.position) - sphere.radius;
}


float opSmoothUnion( float d1, float d2, float k )
{
    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );
    return lerp( d2, d1, h ) - k*h*(1.0-h);
}

float opUnion( float d1, float d2 ) { return min(d1,d2); }

// // Function to estimate the normal at a point on the SDF surface
// float3 EstimateNormal(float3 p)
// {
//     const float epsilon = 0.01; // Small offset value for normal calculation
//     const float3 up = float3(0, epsilon, 0);
//     const float3 right = float3(epsilon, 0, 0);
//     const float3 forward = float3(0, 0, epsilon);
//
//     // Central difference to approximate gradient (normal)
//     return normalize(float3
//     (
//         SphereSDF(p + right) - SphereSDF(p - right),
//         SphereSDF(p + up) - SphereSDF(p - up),
//         SphereSDF(p + forward) - SphereSDF(p - forward)
//     ));
// }


// Half Lambert shading function
float HalfLambert(float3 normal, float3 lightDir)
{
    float ndotl = dot(normal, lightDir) * 0.5 + 0.5; // Scale and bias the dot product
    return ndotl * ndotl; // Square to accentuate the effect
}

// Scene SDF that combines all spheres
float SceneSDF(float3 p)
{
    float sceneDist = 1e5; // Start with a very large number
    for (int i = 0; i < numSpheres; ++i) {
        float d = SphereSDF(p, spheres[i]);
        sceneDist = min(sceneDist, d);
    }
    return sceneDist;
}

// Raymarching routine
float Raymarch(float3 rayOrigin, float3 rayDirection)
{
    float3 lightDir = normalize(float3(1, 1, -1));
    
    float distanceTravelled = 0.0;
    for (int i = 0; i < MAX_STEPS; i++)
    {
        // Ray point is ray origin + ray direction * distance travelled
        float3 p = rayOrigin + rayDirection * distanceTravelled;

        float dist = SceneSDF(p);// opSmoothUnion(distToSphereCenter, distToSphereRight, _Smoothing);
        //finalDist = opUnion(finalDist, distToSphereLeft);
        
        
        if (dist < HIT_THRESHOLD)
        {
            // We hit the surface            
            return  distanceTravelled;
        }
        
        // Move along the ray
        distanceTravelled += dist;
        if (distanceTravelled > MAX_DISTANCE)
        {
            // We didn't hit anything
            return MAX_DISTANCE;
        }
    }
    return MAX_DISTANCE;
}

// Converts a screen position to a ray direction
float3 GetRayDirection(float2 uv)
{
    float4 clipSpacePosition = float4(uv * 2.0 - 1.0, 0, 1);
    float4 cameraSpacePosition = mul(_InverseProjection, clipSpacePosition);
    cameraSpacePosition /= cameraSpacePosition.w;
    float3 worldSpaceRay = mul(_CameraToWorld, cameraSpacePosition).xyz;
    return normalize(worldSpaceRay - _CameraToWorld[3].xyz);
}

// Main compute shader thread
// Currently testing by putting in default values for the ro and rd
[numthreads(32, 32, 1)]
void RunRaymarcher(uint3 id : SV_DispatchThreadID)
{
    float2 uv = (id.xy + 0.5) / _Resolution.xy;
    float2 centeredUV = uv * 2.0 - 1.0;
    float3 rayDir = normalize(float3(centeredUV.x, centeredUV.y,1));// GetRayDirection(uv);
    float3 rayOrigin = float3(0,0,-4);// _CameraToWorld[3].xyz; // Camera's position in world space

    float distance = Raymarch(rayOrigin, rayDir);
    float marchValue = distance < MAX_DISTANCE ? 1 : 0;
    float4 color = distance < MAX_DISTANCE ? float4(1, 0, 0, 1) : float4(0, 0, 0, 1); // Red if we hit the sphere

    Result[id.xy] = float4(rayDir.x,0,marchValue,1);// color; // UV Works - float4(uv.x, uv.y,0,0);
}
